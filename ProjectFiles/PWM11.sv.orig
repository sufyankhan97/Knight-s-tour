<<<<<<< HEAD
module PWM11(clk, rst_n, duty, PWM_sig, PWM_sig_n);
	
	input clk, rst_n;
	input [10:0] duty;
	output logic PWM_sig, PWM_sig_n;
	
	logic [10:0] cnt;
	logic top_PWM_on;
	
	// counter to compare duty against
	always_ff @(posedge clk, negedge rst_n)
	if (!rst_n)
		cnt <= 11'h000;
	else
		cnt <= cnt+1;
	
	// set duty on only if its greater than count. Can't achieve 100% ON
	assign top_PWM_on = duty > cnt ? 1 : 0;
	
	// flip flop to prevent glitches on PWM output
	always_ff @(posedge clk, negedge rst_n)
	if (!rst_n)
		PWM_sig <= 0;
	else
		PWM_sig <= top_PWM_on;
	
	assign PWM_sig_n = ~PWM_sig;

endmodule
=======
module PWM11(clk, rst_n, duty, PWM_sig,PWM_sig_n);
input clk, rst_n;
input [10:0] duty;
output reg PWM_sig, PWM_sig_n;
logic [10:0] cnt;
logic inter;
always_ff @(posedge clk, negedge rst_n) begin //up counter
	if (!rst_n) cnt <= 11'h000;
	else cnt <= cnt + 1; 
end
assign inter = (cnt<duty) ? 1:0;
always_ff @(posedge clk, negedge rst_n) begin //flopping PWM directly to avoid glitch
	if (!rst_n) PWM_sig <= 1'b0;
	else PWM_sig <= inter;
end
assign PWM_sig_n = ~PWM_sig; 
endmodule 
>>>>>>> 88be81a3ad76492ecc2dbd92f5edc2c8e68f8c99
